[

  {
    "topic" : "Sorting",
    "questions":[
      {
        "question" : "What is the worst-case run time of quicksort?",
        "choices" : [
          "O(1)",
          "O(n)",
          "O(n*log(n))",
          "O(n<sup>2</sup>)",
          "O(2<sup>n</sup>)"
        ],
        "answer" : 3
      },
      {
        "question" : "What is the average run time of quicksort?",
        "choices" : [
          "O(1)",
          "O(n)",
          "O(n*log(n))",
          "O(n<sup>2</sup>)",
          "O(2<sup>n</sup>)"
        ],
        "answer" : 2
      },
      {
        "question" : "What is the best-case run time of quicksort with a simple partition?",
        "choices" : [
          "O(1)",
          "O(n)",
          "O(n*log(n))",
          "O(n<sup>2</sup>)",
          "O(2<sup>n</sup>)"
        ],
        "answer" : 2
      },
      {
        "question" : "What is the best-case run time of quicksort with a three-way partition?",
        "choices" : [
          "O(1)",
          "O(n)",
          "O(n*log(n))",
          "O(n<sup>2</sup>)",
          "O(2<sup>n</sup>)"
        ],
        "answer" : 1
      },
      {
        "question" : "How can you make quicksort stable? A stable sort is if two items \"tie\" when compared, sorting will not change their original relative placement. Ex: [. . ., a1, . . ., a2, . . .] -> [. . ., a1, a2, . . .]",
        "choices" : [
          "It's impossible. Quicksort cannot be stable",
          "Add an extra key to each element of its original place in the array, and use that as a tie-breaker when comparing elements.",
          "Sort the whole array twice, first by one key, then by a second key.",
          "Quicksort is supposed to be quick, not stable. You hurt my feelings.",
          "O(2<sup>n</sup>)"
        ],
        "answer" : 1
      },
      {
        "question" : "What is the average run time of HeapSort?",
        "choices" : [
          "O(1)",
          "O(n)",
          "O(n*log(n))",
          "O(n<sup>2</sup>)",
          "O(2<sup>n</sup>)"
        ],
        "answer" : 2
      },
      {
        "question" : "What is the runtime to make a heap from N elements?",
        "choices" : [
          "O(1)",
          "O(n)",
          "O(n*log(n))",
          "O(n<sup>2</sup>)",
          "O(2<sup>n</sup>)"
        ],
        "answer" : 1
      },
      {
        "question" : "What is the runtime of mergesort?",
        "choices" : [
          "O(1)",
          "O(n)",
          "O(n*log(n))",
          "O(n<sup>2</sup>)",
          "O(2<sup>n</sup>)"
        ],
        "answer" : 2
      },
      {
        "question" : "What is the space complexity of mergesort?",
        "choices" : [
          "O(1)",
          "O(n)",
          "O(n*log(n))",
          "O(n<sup>2</sup>)",
          "O(2<sup>n</sup>)"
        ],
        "answer" : 2
      },
      {
        "question" : "How does insertion sort work?",
        "choices" : [
          "You insert each element into a data structure.",
          "The algorithm prays to the evil gods that roam the world beneath us to tell it what to do with each element. Runtime is O(Higs Boson).",
          "You traverse the array while swapping each pair of elements that are in the incorrect order. Repeat until sorted",
          "Algorithmically, you take each element and swap it with the smallest element, rotating through to the largest, until you have sorted the elements.",
          "The algorithm takes each element and inserts it into the correct position in an array or list."
        ],
        "answer" : 4
      },
      {
        "question" : "What is the runtime of insertion sort?",
        "choices" : [
          "O(1)",
          "O(n)",
          "O(n*log(n))",
          "O(n<sup>2</sup>)",
          "O(2<sup>n</sup>)"
        ],
        "answer" : 3
      },
      {
        "question" : "When might insertion sort be most useful?",
        "choices" : [
          "Insertion sort is never useful and should never be used.",
          "Insertion sort is useful when you have a list or array already sorted and you only need to insert one element.",
          "Insertion sort can be used to find out which computer scientist is the sexiest. They might be right next to you. Or very very far away. Either way, start running.",
          "Insertion sort helps speed up other algorithms, like graph traversal or matrix multiplication.",
          "Insertion sort be effecticely used as a base case for other sorting algorithms like mergesort when there are only a few elements left to sort, reducing recursive calls on the stack."
        ],
        "answer" : 4
      }

    ]
  },
  {
    "topic" : "Trees",
    "questions" : [
      {
        "question" : "What is a Tree in computer science?",
        "choices" : [
          "A Tree is a recursive data structure where each \"root\" in the tree has K children, also trees themselves. Trees are grown in organic computers made entirely from natural ingredients.",
          "A Tree is an iterative data structure where for each \"root\" in the tree, there are K children, also trees. Trees can die when they don't get enough water, so you must keep your computer well hydrated.",
          "A Tree will hunt you down, wandering the land for eons until you are stuck in a tower and surrounded by these ent-like data types. Fear them.",
          "Trees fear fire and bacteria. Use them wisely.",
          "A tree is the recursive data structure described in the first option, but are not grown organically. Lots of pesticides are used to sanitize the data."
        ],
        "answer" : 4
      },
      {
        "questions" : "What is a binary search tree (BST)?",
        "choices" : [
          "A BST is a tree where each node has 2 children. You can search for a node by asking which is the favorite child of the root, or parent.",
          "A BST is a tree where each node is null.",
          "A BST is a tree where each node has two children. The right child has a pointer less than the node itself, and the left pointer is the largest pointer.",
          "A BST is a tree where each node has two children. The value of the left child in the smallest, and the right child has the largest value.",
          "A BST is a tree with two children. The value of the left child is the greatest, and the right child has the least value."
        ],
        "answer" : 3
      }
    ]
  },

  {
  "topic" : "Hash Tables",
  "questions": [
    {
      "question" : "What is a collision?",
      "choices" : [
        "When your server is on a truck and it hits another truck.",
        "When two hash tables hit each other while approaching the speed of light.",
        "When two items hash to the same key value.",
        "When two keys have the same data entry.",
        "When someone overwrites a hash table with another hash table."
      ],
      "answer" : 2
    },
    {
      "question" : "What are some possible ways to handle collisions?",
      "choices" : [
        "Don't bother; it won't ever happen. ;)",
        "Cry uncontrollably until someone smarter figures it out.",
        "Marry Superman. He can fix ANYTHING! But only if you're married to him and give birth to his mighty sperm-children. It's canon.",
        "Use a linked list to hold all the values for each key with the same hash value.",
        "Delete the hash table and start over. Never give up!"
      ],
      "answer" : 3
    },
    {
      "question" : "What are the consequences of collisions?",
      "choices" : [
        "I'll have to answer questions about them in interviews and this god forsaken app.",
        "When two hash tables collide at high speeds, they may create cancer-causing nano-hash-function particles.",
        "You will have a slower insertion time. Worst case, inserting one item will be O(n^2).",
        "You will have a slower insertion time. Worst case, inserting one item will be O(n).",
        "Your family will reject for you being a failure to humanity."
      ],
      "answer" : 3
    },
    {
      "question" : "What do you do if your hash table fills up?",
      "choices" : [
        "The computer will have too much knowledge and try to take over the world",
        "You can make a second hash table that's harder faster better stronger",
        "You can pretend Daft Punk knows anything about this--oh wait that was the prior option",
        "You can remake your hash table 2x the size of the current hash table",
        "You can just stop"
      ],
      "answer" : 3
    },
    {
      "question" : "What are the advantages of using a linked list to resolving collisions rather chaining?",
      "choices" : [
        "With linked lists, the hash table will never fill up",
        "Chains clink a lot so linked lists are quiteter",
        "You get a more even distribution of values in the hash table, so there are less empty slots",
        "The hash table is more neat",
        "It will take less time to find the entry"
      ],
      "answer" : 0
    },
    {
      "question" : "What is quadratic probing, and why is it useful? (H = the hash value of the element.)",
      "choices" : [
        "It is an algorithm for handling collisions in hash tables, where you check H+1, H+2<sup>2</sup>, H+3<sup>2</sup>, ..., H+k<sup>2</sup> until you find an available slot.",
        "It is a way to handle collisions, and you go down to the next available slot: H+1, H+2 etc. until one of them is empty.",
        "It's what aliens do when they kidnap you and take you away. Ew, math.",
        "It's a technique to handle collisions. You use a second, quadratic hash function, and use that to determine the slot. If that's not free, use a different hash function.",
        "Hash tables use quadratic probing to determine if a value is missing."
      ],
      "answer" : 0
    },
    {
      "question" : "What is the runtime of inserting into a hash table, on average?",
      "choices" : [
        "O(1)",
        "O(n)",
        "O(n*log(n))",
        "O(n<sup>2</sup>)",
        "O(2<sup>n</sup>)"
      ],
      "answer" : 0
    },
    {
      "question" : "What is the worst-case runtime of inserting n elements into a hash table?",
      "choices" : [
        "O(1)",
        "O(n)",
        "O(n*log(n))",
        "O(n<sup>2</sup>)",
        "O(2<sup>n</sup>)"
      ],
      "answer" : 3
    },
    {
      "questions" : "What is a bloom filter, and why would you need it?",
      "choices" : [
        "A bloom filter is a hash table with Flower objects during the spring.",
        "A bloom filter is a hash table used to create false positives as a simulation in a stress test.",
        "A bloom filter is a small hash table used to make sure attempted illegal entries do not get into a different, larger hash table.",
        "A bloom filter is a large hash table with a variable amount of elements, used as a filter to eliminate entries that are illegal.",
        "A bloom filter is a space-efficient hash table where a bit-array is used with multiple hash functions to test if an element is present in a set."
      ]
    },
    {
      "question" : "What is a major downside to hash tables?",
      "choices" : [
        "Hash tables cause computers to do extra work that is not necessary.",
        "Hash tables cause computers to overheat because of their slothfulness.",
        "Hash tables take up a lot of space, often using over 1,000 times the space used by, say, a binary tree.",
        "Hash tables hate you. They want to slap you for not giving them ice cream.",
        "The elements are not sorted, so if you need a list of the elements in order, you need a different data structure."
      ],
      "answer" : 1
    }
  ]
}]